<template>
  <div id="sparc-browse">
    <div class="dataset-breadcrumb-gradient">
      <el-row type="flex" justify="center">
        <el-col :xs="22" :sm="22" :md="22" :lg="18" :xl="16">
          <div class="breadcrumb">
            <span class="segment">
              <a href="#">Data Core</a>
            </span>
            <span class="divider">/</span>
            <span class="segment">
              <a href="#">{{ title }}</a>
            </span>
          </div>
        </el-col>
      </el-row>
    </div>
    <div id="left-content-column">
      <div class="content-container__info__title">WELCOME TO THE SPARC DATAPORTAL</div>
      <div
        class="content-container__info__text"
      >The Sparc Dataportal is an easily accessible resource to find, visualize and access data generated by the NIH SPARC project.</div>
    </div>
    <div id="right-content-column">
      <div class="sparc-browse">
        <div class="browse-search-area">
          <div class="browse-search-bar">
            <sparc-browse-search
              v-bind:models="models"
              v-bind:activeModel="activeModel"
              @labelChanged="onLabelChanged"
            />
            <sparc-browse-filter
              @addFilter="onAddFilter"
              v-bind:activeModel="activeModel"
              v-bind:hops="hops"
            />
          </div>
          <div class="browse-filter-labels" id="filter-labels">
            <sparc-filter-list
              ref="filterLabels"
              v-bind:filters="filters"
              @filterRemoved="onFilterRemoved"
            />
          </div>
        </div>
        <div class="browse-table">
          <el-table
            :data="tableData"
            @sort-change="sortChange"
            style="width: 100%"
            v-bind:height="calcHeight"
          >
            <!-- <el-table-column
                            fixed="left"
                            label=""
                            width="100">
                            <template slot-scope="scope">
                                <div class="filter_action">
                                    <el-button icon="el-icon-view" circle size="mini"
                                    @click.native.prevent="handleClickLookup(scope.$index, tableData)"></el-button>
                                </div>
                                <el-button
                                @click.native.prevent="handleClickLookup(scope.$index, tableData)"
                                type="text" size="small">Lookup</el-button>
                            </template>
            </el-table-column>-->
            <el-table-column
              v-for="tableColumn in tableColumns"
              :key="tableColumn.name"
              v-bind:prop="tableColumn.prop"
              v-bind:label="tableColumn.name"
              sortable="custom"
              width="200"
            />
            <el-table-column fixed="right" label="Action" width="150">
              <template slot-scope="scope">
                <div class="filter_action">
                  <el-button
                    icon="el-icon-view"
                    circle
                    size="mini"
                    @click.native.prevent="handleClickLookup(scope.$index, tableData)"
                  ></el-button>
                  <el-select
                    v-if="hasFilters"
                    size="mini"
                    v-model="filterActionValue"
                    placeholder="Select"
                  >
                    <el-option
                      v-for="item in filterModels"
                      :key="item.value"
                      :label="item.label"
                      :value="item.value"
                    ></el-option>
                  </el-select>
                  <el-button
                    v-if="hasFilters"
                    icon="el-icon-search"
                    circle
                    size="mini"
                    @click.native.prevent="handleClickLookup(scope.$index, tableData)"
                  ></el-button>
                </div>
                <!-- <el-button
                                @click.native.prevent="handleClickLookup(scope.$index, tableData)"
                type="text" size="small">Lookup</el-button>-->
              </template>
            </el-table-column>
            <infinite-loading
              slot="append"
              @infinite="infiniteHandler"
              force-use-infinite-wrapper=".el-table__body-wrapper"
            ></infinite-loading>
          </el-table>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import InfiniteLoading from "vue-infinite-loading";
import SparcBrowseSearch from "../sparc-browse-search/SparcBrowseSearch.vue";
import SparcBrowseFilter from "../sparc-browse-filter/SparcBrowseFilter.vue";
import SparcFilterList from "../sparc-filter-list/SparcFilterList.vue";

export default {
  components: {
    InfiniteLoading,
    SparcBrowseSearch,
    SparcBrowseFilter,
    SparcFilterList
  },
  name: "sparc-browse",

  data() {
    return {
      tableColumns: [],
      tableData: [],
      event: [],
      filterOptions: { prop: "", order: "ascending" },
      scrollState: "",
      models: [],
      activeModel: "",
      filters: [],
      hops: 3,
      ev: {},
      hideProps: [
        "label",
        "updatedAt",
        "createdAt",
        "updatedBy",
        "createdBy",
        "deleted",
        "organizationId",
        "datasetId"
      ],
      calcHeight: "calc(100vh - " + 140 + "px)",
      filterActionValue: ""
    };
  },
  computed: {
    visibleRecords() {
      return this.tableData.slice(
        (this.currentPage - 1) * this.pageSize,
        this.currentPage * this.pageSize
      );
    },
    hasFilters() {
      return this.filters.length > 0;
    },
    filterModels() {
      var models = [];
      for (var item in this.filters) {
        models.push({
          value: this.filters[item]["model"],
          label: this.filters[item]["model"]
        });
      }
      this.filterActionValue = models[0]["value"];
      return models;
    }
  },
  watch: {
    filters: function(val) {
      clearTimeout(this.timeout);
      this.timeout = setTimeout(() => {
        if (this.$refs.filterLabels) {
          const filterHeight = this.$refs.filterLabels.$el.clientHeight + 120;
          this.calcHeight = "calc(100vh - " + filterHeight + "px)";
        }
      }, 400);
    }
  },

  props: {},
  methods: {
    handleClickLookup(index, data) {
      // On Filter lookup, we want to be able to show which records
      // of a particular model that was leveraged in filter matched

      const filterModel = this.activeModel;
      // Set query model to the selected filter-model
      this.activeModel = this.filterActionValue;

      // Add Filter for ID of current row
      this.addFilter({
        model: filterModel,
        m: filterModel + ":id",
        o: "CONTAINS",
        v: data[index]["id"]
      });
    },
    onFilterRemoved(ev) {
      this.ev = ev;
      this.filters.splice(this.filters.indexOf(ev), 1);
      this.updateURI();
      this.requestData(0, 50);
    },
    onLabelChanged(ev) {
      this.tableData = [];
      this.activeModel = ev.value;

      if (this.scrollState) {
        this.scrollState.reset();
      }

      this.tableColumns = [];
      this.updateURI();
      this.requestData(0, 50);
      this.updateColumnHeaders();
    },
    updateURI() {
      const m = encodeURI(this.activeModel);
      const q = window.btoa(this.filters);

      this.$router.push({ path: "models", query: { model: m, filters: q } });
    },
    sortChange(ev) {
      this.event = ev;
      if (this.scrollState) {
        this.scrollState.reset();
      }
      this.filterOptions = { prop: ev.prop, order: ev.order };
      this.requestData(0, 50);
    },
    updateColumnHeaders() {
      var req_str = "../api/db/model/" + this.activeModel + "/props";

      this.axios
        .get(req_str)
        .then(response => {
          var columnHeaders = [];
          for (var k in response.data) {
            if (!this.hideProps.includes(response.data[k])) {
              columnHeaders.push({
                name: response.data[k],
                prop: response.data[k]
              });
            }
          }
          this.tableColumns = columnHeaders;
        })
        .catch(e => {
          console.log(e);
        });
    },
    onAddFilter(ev) {
      console.log("adding filter");
      this.addFilter({
        model: ev.model,
        m: ev.prop,
        o: ev.operand,
        v: ev.value
      });
    },
    addFilter(newFilter) {
      this.filters.push(newFilter);
      this.updateURI();

      if (this.scrollState) {
        this.scrollState.reset();
      }

      this.requestData(0, 50);
    },
    requestData(offset, limit, append) {
      const orderby = encodeURIComponent(this.filterOptions["prop"]);
      const descend = encodeURIComponent(this.filterOptions["order"]);
      const activeModel = encodeURIComponent(this.activeModel);

      var req_str =
        "../api/db/model/" +
        activeModel +
        "?offset=" +
        offset +
        "&limit=" +
        limit +
        "&hops=" +
        this.hops;
      if (orderby) {
        req_str += "&orderby=" + orderby + "&desc=" + descend;
      }
      if (this.filters) {
        const filters = encodeURIComponent(JSON.stringify(this.filters));
        console.log("Request Filters: " + filters);
        req_str += "&filters=" + filters;
      }

      console.log(req_str);
      this.axios
        .get(req_str)
        .then(response => {
          console.log("get results");
          if (append) {
            this.tableData = this.tableData.concat(response.data);
            if (this.scrollState) {
              if (response.data.length > 0) {
                this.scrollState.loaded();
              } else {
                this.scrollState.complete();
              }
            }
          } else {
            this.tableData = response.data;
            if (this.scrollState) {
              if (response.data.length > 0) {
                this.scrollState.loaded();
              } else {
                this.scrollState.complete();
              }
            }
          }
        })
        .catch(e => {
          console.log(e);
        });
    },
    infiniteHandler(state) {
      console.log(this.tableData);
      if (this.tableData.length > 0) {
        this.scrollState = state;
        if (this.activeModel) {
          this.requestData(this.tableData.length, 50, true);
        } else {
          state.complete();
        }
      } else {
        state.reset();
      }
    }
  },
  mounted() {
    console.log("---" + this.$refs.filterLabels.$el.clientHeight);
    this.axios
      .get("../api/db/labels ")
      .then(response => {
        this.models = response.data;
      })
      .catch(e => {
        console.log(e);
      });
  }
};
</script>

<style lang="scss" scoped>
#sparc-browse {
  display: flex;
  flex-direction: row;
  width: 100%;
}

.sparc-browse {
  margin-right: 8px;
  margin-bottom: 8px;
  display: flex;
  flex-direction: column;
}

.browse-table {
  border: 1px solid lightgray;
}

.browse-search-area {
  flex-direction: column;
  display: flex;
  justify-content: space-between;
}

.browse-search-bar {
  display: flex;
  margin-bottom: 8px;
  justify-content: space-between;
}

.browse-filter-labels {
  display: flex;
  margin-bottom: 8px;
}

#left-content-column {
  flex: 0;
  flex-basis: 250px;
}

#right-content-column {
  flex: 1;
  overflow: scroll;
}

.filter_action {
  display: flex;
}
</style>
